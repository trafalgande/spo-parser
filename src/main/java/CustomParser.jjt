options {
  MULTI=true;
  NODE_DEFAULT_VOID=true;
}

PARSER_BEGIN(CustomParser)

import java.io.FileNotFoundException;
import java.util.*;

public class CustomParser {
    public static void main(String[] args) {
       CustomParser customParser = null;
       if (args.length < 1) {
           customParser = new CustomParser(System.in);
       } else {
           try {
                customParser = new CustomParser(new java.io.DataInputStream(new java.io.FileInputStream(args[0])));
           } catch(FileNotFoundException e) {
                customParser = new CustomParser(System.in);
           }
       }
       try {
           ASTStart root = customParser.Start();
           root.dump("");
           JsonDTO jsonDTO = new JsonDTO();
           com.google.gson.Gson gson = new com.google.gson.Gson();
           for(int i = 0; i < root.jjtGetNumChildren(); i++) {
               Node current = root.jjtGetChild(i);
                   if (current.toString().contains(":")) {
                       String[] split = current.toString().split(":");
                       switch (split[0]) {
                              case "Command" : {
                                  jsonDTO.setCmd(split[1].trim());
                                  break;
                              }
                              case "Param" : {
                                  jsonDTO.setParam(split[1].trim());
                                  break;
                              }
                              case "Path" : {
                                  jsonDTO.setPath(split[1].trim());
                                  break;
                              }
                              case "New Element" : {
                                  jsonDTO.setNelem(split[1].trim());
                                  break;
                              }
                          }
                   }
                   if (current.jjtGetNumChildren() > 0) {
                       ArrayList list = new ArrayList();
                       ArrayList condList = new ArrayList();
                       String and_or = "";
                   for(int j = 0; j < current.jjtGetNumChildren(); j++) {
                       Node subCurrent = current.jjtGetChild(j);
                         if ("and_or".equals(subCurrent.toString().split(":")[0])) {
                                                         and_or = subCurrent.toString().split(":")[1].trim();
                                                         list.add("&&".equals(and_or) ? 1 : 0);
                                                  }
                       if (subCurrent.jjtGetNumChildren() > 0) {
                          SubCondDTO subCondDTO = new SubCondDTO();
                           for(int k = 0; k < subCurrent.jjtGetNumChildren(); k++) {
                               Node subSubCurrent = subCurrent.jjtGetChild(k);

                                if (subSubCurrent.toString().contains(":")) {
                                  String[] split = subSubCurrent.toString().split(":");
                                  switch (split[0]) {
                                      case "key" : {
                                         subCondDTO.setKey(split[1].trim());
                                         break;
                                      }
                                     case "value" : {
                                         subCondDTO.setValue(split[1].trim());
                                         break;
                                     }
                                     case "Sign": {
                                         subCondDTO.setSign(split[1].trim());
                                         break;
                                     }
                                  }
                              }
                           }
                           jsonDTO.append(subCondDTO);
                            jsonDTO.setGlobal_sign(list);
                       }
                   }

               }
           }

           String json = gson.toJson(jsonDTO);
           System.out.println(json);
       } catch (Exception e) {
//           System.out.print("\t[-] Wrong input\n>\t");
           System.out.println(e.getMessage());
       }
    }
}


PARSER_END(CustomParser)

SKIP : { " " | "\t" }

TOKEN : { <EOL : "\n" | "\r" | "\r\n" > }

TOKEN : {
    <CMD: "create" | "read" | "update" | "delete" >
    | <DIR_OR_NODE: "dir" | "node"  >

    | <QUOTE: "\'" | "\"">
    | <#LETTER: ["a"-"z", "A"-"Z"] >
    | <#DIGIT: ["0"-"9"] >
    | <#DOT : "." >
    | <WORD: (<LETTER>)+ | (<DIGIT>)+ >
    | <PATH: <DOT> | (<WORD>(<DOT>)?)+ >

    | <#eq: "=" >
    | <#neq: "!=" >
    | <#gt: ">" >
    | <#lt: "<" >
    | <COMPARE: <eq> | <neq> | <gt> | <lt> >

    | <#and: "&&" >
    | <#or: "||" >
    | <AND_OR: <and> | <or> >
}

ASTStart Start() #Start : {}
{
  Input() <EOL>
  { return jjtThis; }
}

void Input() : {}
{
    Command() ( DirOrNode() )? Path()( NewElement() )?(("with value" | "with values") "[" Condition() "]")?
}

void Path() #Path : {Token t;}
{
    t=<PATH> {jjtThis.setName(t.image);}
}

void DirOrNode() #DirOrNode : {Token t;}
{
    t=<DIR_OR_NODE> {jjtThis.setName(t.image);}
}

void Command() #Command : {Token t;}
{
    t=<CMD> {jjtThis.setName(t.image);}
}

void Condition() #Condition : {}
{
    SubCondition() [(AndOr() SubCondition())+]
}

void SubCondition() #SubCondition : {}
{
    key() CompareSign() (val() | <QUOTE> val() <QUOTE>)
}

void key() #key : {Token t;}
{
    t=<WORD> {jjtThis.setName(t.image);}
}

void val() #val : {Token t;}
{
    t=<WORD> {jjtThis.setName(t.image);}
}


void CompareSign() #CompareSign : {Token t;}
{
    t=<COMPARE> {jjtThis.setName(t.image);}
}

void AndOr() #AndOr : {Token t;}
{
    t=<AND_OR> {jjtThis.setName(t.image);}
}

void NewElement() #NewElement : {Token t;}
{
    t="!"<WORD> {jjtThis.setName(t.next.image);}
}

